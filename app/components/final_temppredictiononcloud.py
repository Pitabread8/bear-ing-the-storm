# -*- coding: utf-8 -*-
"""Final_TempPredictionOnCloud.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ARHYPUmb1IljItJdecAcRufNXVNAP44i
"""

# This program entirely runs on a cloud application (Flask)
# and conducts monthly predictions of temperature, precipitation rate, and wind speed
# at any given location
# using GLDAS Data stored on the Google Earth Engine Platform
!pip install -q earthengine-api geemap pandas scikit-learn pyngrok flask requests

# Import all packages
import ee
import geemap
import pandas as pd
import numpy as np
from sklearn.linear_model import LinearRegression
from datetime import datetime, timedelta
from flask import Flask, request, jsonify
from pyngrok import ngrok
import requests
from google.colab import files

# Authenticate GEE project
uploaded = files.upload()  # select your JSON key file
service_account = "XXXXX" #add service account credential
key_file = list(uploaded.keys())[0] # .json key file is stored privately for security purposes. Upload own key file created using GEE service account.

credentials = ee.ServiceAccountCredentials(service_account, key_file)
ee.Initialize(credentials, project="bearing-the-storm") #replace with your project connected with the service account

# Prediction models for temp
def get_monthly_temps(lat, lon, start, end):
    point = ee.Geometry.Point([lon, lat])
    coll = (
        ee.ImageCollection("NASA/GLDAS/V021/NOAH/G025/T3H")
        .select("Tair_f_inst")
        .filterDate(start, end)
        .map(lambda img: ee.Feature(None,
                                    img.reduceRegion(ee.Reducer.mean(),
                                                     geometry=point,
                                                     scale=25000)
                                    .set("img_date", img.date().format("YYYY-MM"))
                                   )
            )
    )
    img_dates = coll.aggregate_array("img_date").getInfo()
    temps = coll.aggregate_array("Tair_f_inst").getInfo()

    df = pd.DataFrame({"img_date": img_dates, "tempK": temps})
    df = df.dropna(subset=["img_date", "tempK"])
    df["date"] = pd.to_datetime(df["img_date"], format="%Y-%m", errors="coerce")
    df["tempC"] = df["tempK"] - 273.15
    df["year"] = df["date"].dt.year
    df["month"] = df["date"].dt.month

    df = df.groupby(["year", "month"], as_index=False).agg({"tempC": "mean"}).sort_values(["year","month"]).reset_index(drop=True)
    return df

def predict_future_temp(lat, lon, year, month):
    end_date = datetime.utcnow()
    start_date = end_date - timedelta(days=365*2)
    df = get_monthly_temps(lat, lon, start_date.strftime("%Y-%m-%d"), end_date.strftime("%Y-%m-%d"))

    if len(df) < 6:
        raise ValueError("Not enough data to train model.")

    df["t"] = np.arange(len(df))
    X = df[["t", "month"]]
    y = df["tempC"]

    model = LinearRegression()
    model.fit(X, y)

    last_t = df["t"].iloc[-1]
    future_t = last_t + ((year - df["year"].iloc[-1]) * 12 + (month - df["month"].iloc[-1]))
    X_future = np.array([[future_t, month]])
    pred = model.predict(X_future)[0]

    return pred

# Prediction models for precipitation
def get_monthly_percp(lat, lon, start, end):
    point = ee.Geometry.Point([lon, lat])
    coll = (
        ee.ImageCollection("NASA/GLDAS/V021/NOAH/G025/T3H")
        .select("Rainf_f_tavg")
        .filterDate(start, end)
        .map(lambda img: ee.Feature(None,
                                    img.reduceRegion(ee.Reducer.mean(),
                                                     geometry=point,
                                                     scale=25000)
                                    .set("img_date", img.date().format("YYYY-MM"))
                                   )
            )
    )
    img_dates = coll.aggregate_array("img_date").getInfo()
    rain = coll.aggregate_array("Rainf_f_tavg").getInfo()

    df = pd.DataFrame({"img_date": img_dates, "rainMM": rain})
    df = df.dropna(subset=["img_date", "rainMM"])
    df["date"] = pd.to_datetime(df["img_date"], format="%Y-%m", errors="coerce")
    df["year"] = df["date"].dt.year
    df["month"] = df["date"].dt.month

    df = df.groupby(["year", "month"], as_index=False).agg({"rainMM": "mean"}).sort_values(["year","month"]).reset_index(drop=True)
    return df

def predict_future_percp(lat, lon, year, month):
    end_date = datetime.utcnow()
    start_date = end_date - timedelta(days=365*5)
    df = get_monthly_percp(lat, lon, start_date.strftime("%Y-%m-%d"), end_date.strftime("%Y-%m-%d"))

    if len(df) < 6:
        raise ValueError("Not enough data to train model.")

    df["t"] = np.arange(len(df))
    X = df[["t", "month"]]
    y = df["rainMM"]

    model = LinearRegression()
    model.fit(X, y)

    last_t = df["t"].iloc[-1]
    future_t = last_t + ((year - df["year"].iloc[-1]) * 12 + (month - df["month"].iloc[-1]))
    X_future = np.array([[future_t, month]])
    pred = model.predict(X_future)[0]

    return pred

# Prediction models for wind
def get_monthly_wind(lat, lon, start, end):
    point = ee.Geometry.Point([lon, lat])
    coll = (
        ee.ImageCollection("NASA/GLDAS/V021/NOAH/G025/T3H")
        .select("Wind_f_inst")
        .filterDate(start, end)
        .map(lambda img: ee.Feature(None,
                                    img.reduceRegion(ee.Reducer.mean(),
                                                     geometry=point,
                                                     scale=25000)
                                    .set("img_date", img.date().format("YYYY-MM"))
                                   )
            )
    )
    img_dates = coll.aggregate_array("img_date").getInfo()
    wind = coll.aggregate_array("Wind_f_inst").getInfo()

    df = pd.DataFrame({"img_date": img_dates, "windM": wind})
    df = df.dropna(subset=["img_date", "windM"])
    df["date"] = pd.to_datetime(df["img_date"], format="%Y-%m", errors="coerce")
    df["year"] = df["date"].dt.year
    df["month"] = df["date"].dt.month

    df = df.groupby(["year", "month"], as_index=False).agg({"windM": "mean"}).sort_values(["year","month"]).reset_index(drop=True)
    return df

def predict_future_wind(lat, lon, year, month):
    end_date = datetime.utcnow()
    start_date = end_date - timedelta(days=365*2)
    df = get_monthly_wind(lat, lon, start_date.strftime("%Y-%m-%d"), end_date.strftime("%Y-%m-%d"))

    if len(df) < 6:
        raise ValueError("Not enough data to train model.")

    df["t"] = np.arange(len(df))
    X = df[["t", "month"]]
    y = df["windM"]

    model = LinearRegression()
    model.fit(X, y)

    last_t = df["t"].iloc[-1]
    future_t = last_t + ((year - df["year"].iloc[-1]) * 12 + (month - df["month"].iloc[-1]))
    X_future = np.array([[future_t, month]])
    pred = model.predict(X_future)[0]

    return pred

# Create Flask App
app = Flask(__name__)

@app.route("/", methods=["GET"])
def home():
    return "Flask + Earth Engine backend is running!"

@app.route("/predict", methods=["POST"])
def predict_route():
    try:
        data = request.get_json()
        lat = float(data["lat"])
        lon = float(data["lon"])
        year = int(data["year"])
        month = int(data["month"])
        pred_temp = predict_future_temp(lat, lon, year, month)
        pred_percp = predict_future_percp(lat, lon, year, month)
        pred_wind = predict_future_wind(lat, lon, year, month)
        return jsonify({
            "predicted_temp_C": round(pred_temp, 2),
            "lat": lat,
            "lon": lon,
            "year": year,
            "month": month,
            "predicted_percp_mm": round(pred_percp, 2),
            "predicted_wind_m": round(pred_wind, 2)
        })
    except Exception as e:
        return jsonify({"error": str(e)})

# Authenticate public server for Flask
ngrok.set_auth_token("XXXXXXX")  # replace with your ngrok token
tunnel = ngrok.connect(5000)
public_url = tunnel.public_url  # <-- this is a proper string URL
print(public_url)

# Run Flask App to conduct predictions
import threading
def run_app():
    app.run(port=5000, host="0.0.0.0")

threading.Thread(target=run_app).start()

#test POST request
import time
time.sleep(5)  # wait a few seconds for Flask to start

test_url = f"{public_url}/predict"
payload = {"lat": 35, "lon": 140, "year": 2026, "month": 7} #input latitude, longitutde, year and month data
response = requests.post(test_url, json=payload)
print(response.json())